//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t blank_line(int32_t a1);
int32_t explode_bomb(void);
int32_t fun7(int32_t a1, int32_t a2);
int32_t func4(uint32_t a1);
int32_t initialize_bomb(void);
int32_t phase_1(int32_t a1);
int32_t phase_2(int32_t a1);
int32_t phase_3(int32_t str);
int32_t phase_4(int32_t str);
int32_t phase_5(int32_t a1);
int32_t phase_6(int32_t a1);
int32_t phase_defused(void);
int32_t read_line(void);
int32_t read_six_numbers(int32_t str, int32_t * a2);
int32_t secret_phase(void);
int32_t skip(void);
int32_t string_length(int32_t a1);
int32_t strings_not_equal(int32_t a1, char * a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x76727369; // 0x804b220
int32_t g2 = 253; // 0x804b26c
char * g3 = "$"; // 0x804b320
int32_t g4 = 0; // 0x804b480
int32_t g5 = 0; // 0x804b644
int32_t g6 = 0; // 0x804b648
char * g7; // 0x804b680
char * g8; // 0x804b770
int32_t infile = 0; // 0x804b664
int32_t g9;
int32_t g10;

// ------------------------ Functions -------------------------

// From module:   /usr0/droh/213/private/L2/src/bomb.c
// Address range: 0x80489b0 - 0x8048b1d
// Line range:    36 - 113
int main(int argc, char ** argv) {
    if (argc != 1) {
        if (argc != 2) {
            // 0x8048a10
            printf("Usage: %s [<input_file>]\n", *argv);
            exit(8);
            // UNREACHABLE
        }
        int32_t * file_path = (int32_t *)((int32_t)argv + 4); // 0x80489dd
        struct _IO_FILE * file = fopen((char *)*file_path, "r"); // 0x80489e1
        infile = (int32_t)file;
        if (file == NULL) {
            // 0x80489f2
            printf("%s: Error: Couldn't open %s\n", *argv, (char *)*file_path);
            exit(8);
            // UNREACHABLE
        }
    } else {
        // 0x80489c2
        infile = g6;
    }
    // 0x8048a30
    initialize_bomb();
    printf("Welcome this is my little bomb !!!! You have 6 stages with\n");
    printf("only one life good luck !! Have a nice day!\n");
    phase_1(read_line());
    phase_defused();
    printf("Phase 1 defused. How about the next one?\n");
    phase_2(read_line());
    phase_defused();
    printf("That's number 2.  Keep going!\n");
    phase_3(read_line());
    phase_defused();
    printf("Halfway there!\n");
    phase_4(read_line());
    phase_defused();
    printf("So you got that one.  Try this one.\n");
    phase_5(read_line());
    phase_defused();
    printf("Good work!  On to the next...\n");
    phase_6(read_line());
    phase_defused();
    return 0;
}

// Address range: 0x8048b20 - 0x8048b47
int32_t phase_1(int32_t a1) {
    // 0x8048b20
    if (strings_not_equal(a1, "Public speaking is very easy.") == 0) {
        // 0x8048b43
        return 0;
    }
    // 0x8048b3e
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048b48 - 0x8048b97
int32_t phase_2(int32_t a1) {
    // 0x8048b48
    int32_t v1; // bp-28, 0x8048b48
    read_six_numbers(a1, &v1);
    if (v1 != 1) {
        // 0x8048b69
        explode_bomb();
        // UNREACHABLE
    }
    int32_t v2 = 1;
    int32_t v3 = v2 + 1; // 0x8048b76
    int32_t v4 = 4 * v2 + (int32_t)&v1;
    int32_t result = v3 * *(int32_t *)(v4 - 4); // 0x8048b79
    while (*(int32_t *)v4 == result) {
        // 0x8048b88
        if (v3 >= 6) {
            // 0x8048b8e
            return result;
        }
        v2 = v3;
        v3 = v2 + 1;
        v4 = 4 * v2 + (int32_t)&v1;
        result = v3 * *(int32_t *)(v4 - 4);
    }
    // 0x8048b83
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048b98 - 0x8048ca0
int32_t phase_3(int32_t str) {
    // 0x8048b98
    int32_t result; // bp-16, 0x8048b98
    int32_t v1; // bp-8, 0x8048b98
    char v2; // bp-9, 0x8048b98
    uint32_t items_assigned = sscanf((char *)str, "%d %c %d", &result, &v2, &v1); // 0x8048bb7
    if (items_assigned <= 2) {
        // 0x8048bc4
        explode_bomb();
        // UNREACHABLE
    }
    // 0x8048bd3
    g9 = result;
    char v3; // 0x8048b98
    switch (result) {
        case 0: {
            // 0x8048be0
            v3 = 113;
            if (v1 != 777) {
                // 0x8048bef
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 1: {
            // 0x8048c00
            v3 = 98;
            if (v1 != 214) {
                // 0x8048c0f
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 2: {
            // 0x8048c16
            v3 = 98;
            if (v1 != 755) {
                // 0x8048c21
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 3: {
            // 0x8048c28
            v3 = 107;
            if (v1 != 251) {
                // 0x8048c33
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 4: {
            // 0x8048c40
            v3 = 111;
            if (v1 != 160) {
                // 0x8048c4b
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 5: {
            // 0x8048c52
            v3 = 116;
            if (v1 != 458) {
                // 0x8048c5d
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 6: {
            // 0x8048c64
            v3 = 118;
            if (v1 != 780) {
                // 0x8048c6f
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        case 7: {
            // 0x8048c76
            v3 = 98;
            if (v1 != 524) {
                // 0x8048c81
                explode_bomb();
                // UNREACHABLE
            }
            // break -> 0x8048c8f
            break;
        }
        default: {
            // 0x8048c88
            explode_bomb();
            // UNREACHABLE
        }
    }
    // 0x8048c8f
    if (v2 == v3) {
        // 0x8048c99
        return result;
    }
    // 0x8048c94
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048ca0 - 0x8048cde
int32_t func4(uint32_t a1) {
    int32_t result = 1; // 0x8048cae
    if (a1 >= 2) {
        int32_t v1 = func4(a1 - 1); // 0x8048cb7
        result = func4(a1 - 2) + v1;
    }
    // 0x8048cd5
    return result;
}

// Address range: 0x8048ce0 - 0x8048d2b
int32_t phase_4(int32_t str) {
    // 0x8048ce0
    int32_t v1; // bp-8, 0x8048ce0
    if (sscanf((char *)str, "%d", &v1) != 1) {
        // 0x8048d09
        explode_bomb();
        // UNREACHABLE
    }
    int32_t v2 = v1; // 0x8048d03
    if (v2 >= 0 != v2 != 0) {
        // 0x8048d09
        explode_bomb();
        // UNREACHABLE
    }
    // 0x8048d0e
    if (func4(v2) == 55) {
        // 0x8048d27
        return 55;
    }
    // 0x8048d22
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048d2c - 0x8048d95
int32_t phase_5(int32_t a1) {
    // 0x8048d2c
    if (string_length(a1) != 6) {
        // 0x8048d48
        explode_bomb();
        // UNREACHABLE
    }
    // 0x8048d4d
    int32_t v1; // bp-12, 0x8048d2c
    int32_t v2 = &v1; // 0x8048d4f
    for (int32_t i = 0; i < 6; i++) {
        unsigned char v3 = *(char *)(i + a1); // 0x8048d57
        char v4 = *(char *)((int32_t)(v3 % 16) + (int32_t)&g1); // 0x8048d5f
        *(char *)(i + v2) = v4;
    }
    // 0x8048d6b
    if (strings_not_equal(v2, "giants") == 0) {
        // 0x8048d8c
        return 0;
    }
    // 0x8048d87
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048d98 - 0x8048e91
int32_t phase_6(int32_t a1) {
    // 0x8048d98
    int32_t v1; // bp-28, 0x8048d98
    read_six_numbers(a1, &v1);
    int32_t v2 = &v1;
    uint32_t v3 = 0;
    int32_t v4 = *(int32_t *)(4 * v3 + v2); // 0x8048dc3
    int32_t v5; // 0x8048d98
    int32_t v6; // bp-52, 0x8048d98
    int32_t v7; // 0x8048e0a
    while (v4 < 7) {
        int32_t v8 = v3 + 1; // 0x8048dd1
        int32_t v9 = v8; // 0x8048dd7
        if (v3 > 4) {
            // 0x8048e02
            v7 = &v6;
            v5 = 0;
            goto lab_0x8048e10;
        }
        if (v4 == *(int32_t *)(4 * v9 + v2)) {
            // 0x8048df1
            explode_bomb();
            // UNREACHABLE
        }
        // 0x8048df6
        v9++;
        while (v9 < 6) {
            // 0x8048de6
            if (v4 == *(int32_t *)(4 * v9 + v2)) {
                // 0x8048df1
                explode_bomb();
                // UNREACHABLE
            }
            // 0x8048df6
            v9++;
        }
        // 0x8048dfc
        if (v8 >= 6) {
            // 0x8048e02
            v7 = &v6;
            v5 = 0;
            goto lab_0x8048e10;
        }
        v3 = v8;
        v4 = *(int32_t *)(4 * v3 + v2);
    }
    // 0x8048dcc
    explode_bomb();
    // UNREACHABLE
  lab_0x8048e10:;
    int32_t v10 = 4 * v5; // 0x8048e18
    int32_t v11 = *(int32_t *)(v10 + v2); // 0x8048e21
    int32_t v12 = 1; // 0x8048e24
    int32_t v13 = &g2; // 0x8048e24
    int32_t v14 = &g2; // 0x8048e24
    if (v11 < 2) {
        goto lab_0x8048e38;
    } else {
        goto lab_0x8048e30;
    }
  lab_0x8048e38:
    // 0x8048e38
    *(int32_t *)(v10 + v7) = v14;
    int32_t v15 = v5 + 1; // 0x8048e3e
    v5 = v15;
    int32_t v16; // 0x8048d98
    int32_t v17; // 0x8048d98
    if (v15 == 6) {
        // 0x8048e44
        v17 = v6;
        v16 = 1;
        goto lab_0x8048e52;
    } else {
        goto lab_0x8048e10;
    }
  lab_0x8048e30:;
    int32_t v18 = *(int32_t *)(v13 + 8); // 0x8048e30
    int32_t v19 = v12 + 1; // 0x8048e33
    v12 = v19;
    v13 = v18;
    v14 = v18;
    if (v19 == v11) {
        goto lab_0x8048e38;
    } else {
        goto lab_0x8048e30;
    }
  lab_0x8048e52:;
    int32_t v20 = *(int32_t *)(4 * v16 + v7); // 0x8048e52
    *(int32_t *)(v17 + 8) = v20;
    int32_t v21 = v16 + 1; // 0x8048e5a
    v17 = v20;
    v16 = v21;
    int32_t v22; // 0x8048d98
    int32_t v23; // 0x8048d98
    int32_t v24; // 0x8048d98
    if (v21 == 6) {
        // 0x8048e60
        *(int32_t *)(v20 + 8) = 0;
        v22 = *(int32_t *)v6;
        v24 = v6;
        v23 = 0;
        goto lab_0x8048e70;
    } else {
        goto lab_0x8048e52;
    }
  lab_0x8048e70:;
    int32_t result = v22; // 0x8048e73
    int32_t v25 = *(int32_t *)(v24 + 8); // 0x8048e70
    int32_t v26 = *(int32_t *)v25; // 0x8048e75
    if (result < v26) {
        // 0x8048e79
        explode_bomb();
        // UNREACHABLE
    }
    int32_t v27 = v23 + 1; // 0x8048e81
    v22 = v26;
    v24 = v25;
    v23 = v27;
    if (v27 >= 5) {
        // 0x8048e87
        return result;
    }
    goto lab_0x8048e70;
}

// Address range: 0x8048e94 - 0x8048ee6
int32_t fun7(int32_t a1, int32_t a2) {
    // 0x8048e94
    if (a1 == 0) {
        // 0x8048ee2
        return -1;
    }
    int32_t v1 = *(int32_t *)a1; // 0x8048eb0
    if (v1 > a2) {
        // 0x8048ee2
        return 2 * fun7(*(int32_t *)(a1 + 4), a2);
    }
    int32_t result = 0; // 0x8048ec7
    if (v1 != a2) {
        // 0x8048ec9
        result = 2 * fun7(*(int32_t *)(a1 + 8), a2) | 1;
    }
    // 0x8048ee2
    return result;
}

// Address range: 0x8048ee8 - 0x8048f48
int32_t secret_phase(void) {
    int32_t v1 = __strtol_internal((char *)read_line(), NULL, 10, 0); // 0x8048efb
    if (v1 >= 1002) {
        // 0x8048f0f
        explode_bomb();
        // UNREACHABLE
    }
    // 0x8048f14
    if (fun7((int32_t)&g3, v1) == 7) {
        // 0x8048f2f
        printf("Wow! You've defused the secret stage!\n");
        return phase_defused();
    }
    // 0x8048f2a
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8048fd8 - 0x8049015
int32_t read_six_numbers(int32_t str, int32_t * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t items_assigned = sscanf((char *)str, "%d %d %d %d %d %d", a2, (int32_t *)(v1 + 4), (int32_t *)(v1 + 8), (int32_t *)(v1 + 12), (int32_t *)(v1 + 16), (int32_t *)(v1 + 20)); // 0x8048fff
    if (items_assigned > 5) {
        // 0x8049011
        return items_assigned;
    }
    // 0x804900c
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x8049018 - 0x8049030
int32_t string_length(int32_t a1) {
    int32_t result = 0; // 0x8049023
    if (*(char *)a1 == 0) {
        // 0x804902c
        return 0;
    }
    int32_t v1 = a1; // 0x8049023
    v1++;
    result++;
    while (*(char *)v1 != 0) {
        // 0x8049025
        v1++;
        result++;
    }
    // 0x804902c
    return result;
}

// Address range: 0x8049030 - 0x8049089
int32_t strings_not_equal(int32_t a1, char * a2) {
    int32_t v1 = (int32_t)a2;
    int32_t v2 = string_length(a1); // 0x8049043
    if (v2 != string_length(v1)) {
        // 0x804907f
        return 1;
    }
    char v3 = *(char *)a1; // 0x8049064
    char v4 = v3; // 0x8049067
    int32_t v5 = v1; // 0x8049067
    if (v3 == 0) {
        // 0x804907f
        return 0;
    }
    int32_t v6 = a1; // 0x8049067
    int32_t result = 1; // 0x8049074
    while (v4 == *(char *)v5) {
        // 0x8049076
        v6++;
        v4 = *(char *)v6;
        v5++;
        result = 0;
        if (v4 == 0) {
            // break -> 0x804907f
            break;
        }
        result = 1;
    }
    // 0x804907f
    return result;
}

// Address range: 0x8049160 - 0x8049179
int32_t initialize_bomb(void) {
    // 0x8049160
    return (int32_t)signal(SIGINT, 0x8048f50);
}

// Address range: 0x804917c - 0x80491ae
int32_t blank_line(int32_t a1) {
    char v1 = *(char *)a1; // 0x8049182
    if (v1 == 0) {
        // 0x80491aa
        return 1;
    }
    char v2 = v1; // 0x804918d
    int32_t v3 = a1; // 0x804918d
    int32_t result = 0; // 0x8049199
    while ((*(char *)(g5 + 1 + 2 * (int32_t)v2) & 32) != 0) {
        // 0x80491a0
        v3++;
        v2 = *(char *)v3;
        result = 1;
        if (v2 == 0) {
            // break -> 0x80491aa
            break;
        }
        result = 0;
    }
    // 0x80491aa
    return result;
}

// Address range: 0x80491b0 - 0x80491fa
int32_t skip(void) {
    // 0x80491b0
    int32_t v1; // bp-28, 0x80491b0
    int32_t v2 = &v1; // 0x80491b6
    int32_t * v3 = (int32_t *)(v2 - 16); // 0x80491d2
    *(int32_t *)(v2 - 8) = infile;
    *(int32_t *)(v2 - 12) = 80;
    *v3 = 80 * g4 + (int32_t)&g7;
    char * str = fgets((char *)&g10, (int32_t)&g10, (struct _IO_FILE *)&g10); // 0x80491d3
    while (str != NULL) {
        // 0x80491e1
        *v3 = (int32_t)str;
        if (blank_line((int32_t)&g10) == 0) {
            // break -> 0x80491f1
            break;
        }
        *(int32_t *)(v2 - 8) = infile;
        *(int32_t *)(v2 - 12) = 80;
        *v3 = 80 * g4 + (int32_t)&g7;
        str = fgets((char *)&g10, (int32_t)&g10, (struct _IO_FILE *)&g10);
    }
    // 0x80491f1
    return (int32_t)str;
}

// Address range: 0x80491fc - 0x80492bd
int32_t read_line(void) {
    // 0x80491fc
    if (skip() == 0) {
        // 0x804920c
        if (infile == g6) {
            // 0x804924a
            printf("Error: Premature EOF on stdin\n");
            explode_bomb();
            // UNREACHABLE
        }
        // 0x8049219
        if (getenv("GRADE_BOMB") != NULL) {
            // 0x804922d
            exit(0);
            // UNREACHABLE
        }
        // 0x8049237
        infile = g6;
        if (skip() == 0) {
            // 0x804924a
            printf("Error: Premature EOF on stdin\n");
            explode_bomb();
            // UNREACHABLE
        }
    }
    int32_t v1 = 80 * g4;
    int32_t result = v1 + (int32_t)&g7;
    int32_t v2 = -1; // 0x8049278
    int32_t v3 = result; // 0x8049278
    int32_t v4 = 0; // 0x8049278
    while (v2 != 0) {
        int32_t v5 = v3;
        v2--;
        v3 = v5 + 1;
        v4 = v2;
        if (*(char *)v5 == 0) {
            // break ->
            break;
        }
        v4 = 0;
    }
    int32_t v6 = -2 - v4; // 0x804927e
    if (v6 != 79) {
        // 0x8049298
        *(char *)(v1 + 0x804b67f + v6) = 0;
        g4++;
        return result;
    }
    // 0x8049286
    printf("Error: Input line too long\n");
    explode_bomb();
    // UNREACHABLE
}

// Address range: 0x80494fc - 0x8049529
int32_t explode_bomb(void) {
    // 0x80494fc
    printf("\nBOOM!!!\n");
    printf("The bomb has blown up.\n");
    exit(8);
    // UNREACHABLE
}

// Address range: 0x804952c - 0x80495a6
int32_t phase_defused(void) {
    // 0x804952c
    if (g4 != 6) {
        // 0x804959f
        int32_t result; // 0x804952c
        return result;
    }
    // 0x804953c
    int32_t v1; // bp-84, 0x804952c
    int32_t v2; // bp-88, 0x804952c
    if (sscanf((char *)&g8, "%d %s", &v2, &v1) != 2) {
        // 0x804959f
        return printf("Congratulations! You've defused the bomb!\n");
    }
    // 0x804955b
    if (strings_not_equal((int32_t)&v1, "austinpowers") == 0) {
        // 0x8049570
        printf("Curses, you've found the secret phase!\n");
        printf("But finding it and solving it are quite different...\n");
        secret_phase();
    }
    // 0x804959f
    return printf("Congratulations! You've defused the bomb!\n");
}

// --------------- Dynamically Linked Functions ---------------

// long int __strtol_internal(const char * restrict nptr, char ** restrict endptr, int base, int group);
// void exit(int status);
// char * fgets(char * restrict s, int n, FILE * restrict stream);
// FILE * fopen(const char * restrict filename, const char * restrict modes);
// char * getenv(const char * name);
// int printf(const char * restrict format, ...);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int sscanf(const char * restrict s, const char * restrict format, ...);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (2.95.3)
// Detected language: C
// Detected functions: 19
